## 并发编程相关概念

世界就是这样一个矛盾体，并发编程能让我们充分地利用CPU资源，提升系统性能。但是同时也给我们带来了很多问题，比如线程上下文切换对性能消耗的问题、共享变量的线程安全问题、线程死锁问题和线程间通信等问题。研究并行编程就是研究怎么在享受多线程编程给我们带来便利的同时又能规避多线程带来的坑。作为一个Java后端开发程序员，我们更应该掌握好多线程编程，因为服务器端对性能的追求是非常高的。

## 一、进程与线程

> 在`Linux`中，线程与进程最大区别就是**是否共享同一块地址空间**，而且共享同一块地址空间的那一组线程将显现相同的`PID`号。

### 1.1 进程

进程是操作系统进行资源分配和调度的最小单元，可以简单地理解为系统中运行的一个程序就是一个进程。

### 1.2 线程

是进程的一个执行单元，是`CPU`调度的最小单元。

### 1.3 进程与线程的区别和联系

1. 一个进程至少包含一个线程，可以包含多个线程，这些线程共享这个进程的资源（比如堆区和方法区资源）。同时每个线程都拥有独立的运行栈和程序计数器，线程切换开销小。
1. 多进程指的是操作系统同时运行多个程序，如当前操作系统中同时运行着QQ、IE、微信等程序。
1. 多线程指的是同一进程中同时运行多个线程，如迅雷运行时，可以开启多个线程，同时进行多个文件的下载。

![进程与线程](/File/Imgs/article/processes%20and%20threads%20.png)

### 1.4 线程号和进程号

1. `PID`: 进程`ID`。
1. `TGID`: 线程组`ID`，也就是线程组`leader`的进程`ID`，等于`PID `。
1. `LWP`: 线程`ID`。在用户态的命令(比如`ps`)中常用的显示方式。
1. `TID`: 线程`ID`，等于`LWP`。`TID`在系统提供的接口函数中更常用，比如`syscall(SYS_gettid)`和`syscall(__NR_gettid)`。


## 二：同步和异步

### 2.1 概念

> 同步和异步通常用来形容一次方法调用。

同步方法调用：调用者必须等到方法调用返回后，才能继续后续的行为。

异步方法调用：方法调用就会立即返回，调用方能立马往下继续执行。被调用的**异步方法其实是由另外的线程进行执行的**，如果这个异步方法有返回值的话可以通过某种通知的方式告知调用方。

### 2.2 实现异步方法的方式

1. 回调函数模式：一个方法被调用后立马返回，调用结果通过回调函数返回给调用方；
1. `MQ`（发布/订阅）：请求方将请求发送到`MQ`，请求处理方监听`MQ`处理这些请求，并将请求处理结果也返回给某个`MQ`，调用方监听这个`Queue`获取处理结果；
1. 多线程处理模式：系统创建其他线程处理调用请求，比如`Spring`中的`@Async`注解标注的方法就是这种方法。
临

## 三：并发和并行

> 并发和并行都可以用来表示两个或者多个任务一起执行，但是侧重点不一样。

- **并发**：是指多个线程任务在同一个`CPU`上**快速地轮换执行**，由于切换的速度非常快，给人的感觉就是这些线程任务是在同时进行的，但其实并发**只是一种逻辑上的同时进行**。

- **并行**：是指多个线程任务在不同`CPU`上同时进行，是真正意义上的同时执行。

贴上一张图来解释下这两个概念：

![并发](/File/Imgs/article/concurrency.png)

这一张是并发的图，我们发现纵坐标某一时刻只有一个任务是在执行的，CPU在不断的切换线程，以极快的速度给人感觉是同时在执行。

![并行](/File/Imgs/article/parallel.png)

这张图，则完美诠释了线程A、B、C同一时刻同时执行。


## 四：临界区和上下文切换

### 4.1 临界区

`临界区`通常指**共享数据**，可以被多个线程使用。当有线程进入到临界区时候，其他线程或者进程必须等待。

> 比如这样一个程序片段：

```java
public class Demo{
    private int age;
    public void setAge(){
        // 临界区
        synchronized{
             age++;
        }
    }
}
```

### 4.2 上下文切换

线程在 `CPU` 上运行之前需要 `CPU` 给这个线程分配时间片，当时间片运行完之后这个线程就会让出 `CPU` 资源给其他的线程运行。但是线程在将 `CPU` 资源让出之前会保存当前的任务状态以便下次获得 `CPU` 资源之后可以继续往下执行。所以**线程从保存当前执行状态到再加载的过程称为一次上下文切换**。

### 4.3 减少上下文切换的措施

1. **无锁并发编程**：多线程竞争锁时，会引起上下文切换，所以多线程处理数据时，可以用一些办法来避免使用锁，如将数据的`ID`按照`Hash`算法取模分段，不同的线程处理不同段的数据；
1. **CAS算法**：`Java`的`Atomic`包使用`CAS`算法来更新数据，而不需要加锁；
1. **使用最少线程**：避免创建不需要的线程，比如任务很少，但是创建了很多线程来处理，这样会造成大量线程都处于等待状态。
1. **协程**：在单线程里实现多任务的调度，并在单线程里维持多个任务间的切换。

## 五：阻塞和非阻塞

> 阻塞和非阻塞通常被用来形容多线程间的相互影响。

当一个线程占用了临界区资源，那么其它需要使用这个资源的线程都必须在这个临界区上等待。等待会导致线程挂起，这样就形成了阻塞。如果占用资源的线程一直没有释放资源，那么其它的线程在这个临界区上都不能继续工作。
相反，非阻塞表明多个线程之间的执行是不会相互影响的。

## 六、死锁、饥饿、活锁和线程安全

### 6.1 死锁

通俗地说，死锁是两个或者多个线程，相互占用对方需要的资源，而都不进行释放，导致彼此之间都相互等待对方释放资源，产生了无限制等待的现象。

> 死锁一旦发生，如果没有外力介入，这种等待将永远存在，从而对程序产生严重的影响。

- 避免死锁的几个方式：

1. 尽量不要一个线程同时占用多个锁；
1. 多个线程加锁的顺序保持一致，尽量避免造成死锁的环路结构；
1. 尝试使用定时锁，使用`lock.tryLock（timeout`）来替代使用内部锁机制；
1. 对于数据库锁，加锁和解锁必须在一个数据库连接里，否则会出现解锁失败的情况。


### 6.2 饥饿

饥饿是指某一个或者多个线程因为种种原因无法获得所需要的资源，导致一直无法执行，比如它的线程优先级可能太低，而高优先级的线程不断抢占它需要的资源，导致低优先级线程无法工作。

> 此外，某一个线程一直占着关键资源不放，导致其他需要这个资源的线程无法正常执行，这种情况也是饥饿的一种。

与死锁相比，饥饿还是有可能在未来一段时间内解决的（比如，高优先级的线程已经完成任务，不再疯狂执行）。

### 6.3 活锁

任务或者执行者没有被阻塞，由于某些条件没有满足，导致一直重复尝试、失败、尝试、失败。活锁和死锁的区别在于，处于活锁的实体时在不断改变状态，活锁有可能自行解开而死锁不能。

### 6.4 线程安全

如果线程的随机调度顺序不影响某段代码的最后执行结果，那么我们认为这段代码是线程安全的。