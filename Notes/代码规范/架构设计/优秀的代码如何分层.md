# 优秀的代码如何分层

> 说起应用分层，大部分人都会认为这个不是很简单嘛 就`Controller`，`Service`, `Mapper`三层。看起来简单，很多人其实并没有把他们职责划分开，在很多代码中,`Controller`做的逻辑比`Service`还多,`Service`往往当成透传了，这其实是很多人开发代码都没有注意到的地方，反正功能也能用，至于放哪无所谓呗。这样往往造成后面代码无法复用，层级关系混乱，对后续代码的维护非常麻烦。

## 一、背景

一个好的应用分层需要具备以下几点:

1. 方便后续代码进行维护扩展；
1. 分层的效果需要让整个团队都接受；
1. 各个层职责边界清晰。

## 二、如何进行分层

### 2.1、阿里规范

在阿里的编码规范中约束的分层如下:

![风尘博客](/File/Imgs/article/代码分层-01.png)

1. 开放接口层：可直接封装 `Service` 方法暴露成` RPC `接口;通过 `Web` 封装成 `http` 接口;进行 网关安全控制、流量控制等。
1. 终端显示层：各个端的模板渲染并执行显示的层。
1. `Web` 层：主要是对访问控制进行转发，各类基本参数校验，或者不复用的业务简单处理等。
1. `Service` 层：相对具体的业务逻辑服务层。
1. `Manager` 层：通用业务处理层，它有如下特征:
	1. 对第三方平台封装的层，预处理返回结果及转化异常信息;
	2. 对`Service`层通用能力的下沉，如缓存方案、中间件通用处理;
	3. 与`DAO`层交互，对多个`DAO`的组合复用。
1. `DAO` 层：数据访问层，与底层 `MySQL`、`Oracle`、`PostgreSQL`进行数据交互。

阿里巴巴规约中的分层比较清晰简单明了，但是描述得还是过于简单了，以及`Service`层和`Manager`层有很多同学还是有点分不清楚之间的关系，就导致了很多项目中根本没有`Manager`层的存在。下面介绍一下具体业务中应该如何实现分层。

### 2.2、优化分层

从我们的业务开发中总结了一个较为的理想模型：

![风尘博客](/File/Imgs/article/代码分层-02.png)

- 最上层`Controller`和`TService`是我们阿里分层规范里面的第一层：轻业务逻辑，参数校验，异常兜底。通常这种接口可以轻易更换接口类型，所以业务逻辑必须要轻，甚至不做具体逻辑。
- `Service`：业务层，复用性较低，这里推荐每一个`Controller`方法都得对应一个`Service`,不要把业务编排放在`Controller`中去做，为什么呢？如果我们把业务编排放在`Controller`层去做的话，如果以后我们要接入其他框架,我们这里又需要把业务编排在做一次，这样会导致我们每接入一个入口层这个代码都得重新复制一份如下图所示:

![风尘博客](/File/Imgs/article/代码分层-03.png)

这样大量的重复工作必定会导致我们开发效率下降，所以我们需要把业务编排逻辑都得放进`Service`中去做:

![风尘博客](/File/Imgs/article/代码分层-04.png)

- `Mannager`：可复用逻辑层。这里的`Mannager`可以是单个服务的，比如我们的`Cache`,`MQ`等等，当然也可以是复合的，当你需要调用多个`Mannager`的时候，这个可以合为一个`Mannager`，比如逻辑上的连表查询等。如果是`httpMannager`或`rpcMannager`需要在这一层做一些数据转换。
- `DAO`：数据库访问层。主要负责“操作数据库的某张表，映射到某个java对象”，`Dao`应该只允许自己的`Service`访问，其他`Service`要访问我的数据必须通过对应的`Service`。

## 三、分层领域模型的转换

### 3.1、在阿里巴巴编码规约中领域模型

- `DO`（Data Object）：与数据库表结构一一对应，通过`DAO`层向上传输数据源对象。
- `DTO`（Data Transfer Object）：数据传输对象，`Service`或`Manager`向外传输的对象。
- `BO`（Business Object）：业务对象。由`Service`层输出的封装业务逻辑的对象。
- `AO`（Application Object）：应用对象。在`Web`层与`Service`层之间抽象的复用对象模型，极为贴近展示层，复用度不高。
- `VO`（View Object）：显示层对象，通常是`Web`向模板渲染引擎层传输的对象。
- `Query`：数据查询对象，各层接收上层的查询请求。注意**超过2个参数的查询封装，禁止使用`Map`类来传输**。

<br>

| 层次 | 领域模型 |
| -- | -- |
| Controller/TService | VO/DTO |
| Service/Mannager | AO/BO |
| DAO | DO |

> 每一个层基本都自己对应的领域模型，这样就导致了有些人过于追求每一层都是用自己的领域模型，这样就导致了一个对象可能会出现3次甚至4次转换在一次请求中，当返回的时候同样也会出现3-4次转换，这样有可能一次完整的请求-返回会出现很多次对象转换。如果在开发中真的按照这么来，恐怕就别写其他的了，一天就光写这个重复无用的逻辑算了吧。

### 3.2、所以我们得采取一个折中的方案:

1. 允许`Service`/`Manager`可以操作数据领域模型，对于这个层级来说，本来自己做的工作也是做的是业务逻辑处理和数据组装
1. `Controller`/`TService`层的领域模型不允许传入`DAO`层，这样就不符合职责划分了。
同理，不允许`DAO`层的数据传入到`Controller`/`TService`。

![风尘博客](/File/Imgs/article/代码分层-05.png)


## 四、关于包名的命名:

### 4.1、`entity`、`model`、`domain`到底怎么用？

根据很多 `Java` 程序员的”经验”来看，一个数据库表则对应着一个 `Domain` 对象，所以很多程序员在写代码时，包名则使用：`com.xxx.domain` ，这样写好像已经成为了行业的一种约束，数据库映射对象就应该是 `domain`。但是你错了，`domain` 是一个领域对象，往往我们再做传统 `Java` 软件 `Web` 开发中，这些 `domain` 都是贫血模型，是没有行为的，或是没有足够的领域模型的行为的，所以，以这个理论来讲，这些 `domain` 都应该是一个普通的 `entity` 对象，并非领域对象，所以请把包名改为:`com.xxx.entity`。

### 4.2、三句话总结下`entity`、`model`、`domain`的不同：

1. `entity`：必须和数据库字段一样
2. `model `：前端需要什么我们就给什么
3. `domain`：很少用，代表一个对象模块

## 五、总结

1. 总的来说业务分层对于代码规范是比较重要，决定着以后的代码是否可复用，是否职责清晰，边界清晰。
1. 当然这种分层其实见仁见智, 团队中的所有人的分层习惯也不同，所以很难权衡出一个标准的准则，总的来说只要满足职责逻辑清晰，后续维护容易，就是好的分层。